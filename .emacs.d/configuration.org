#+TITLE: Emacs Configuration

* Basic

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 100000000) ; Do GC when every 100MB are allocated
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil) ; Don't indent with tabs.
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
#+END_SRC

* UI

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function #'ignore)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t) ; Skip the startup screen
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message "; Hello there!\n; Happy hacking!\n")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p #'y-or-n-p) ; Change yes/no -> y/n
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (fset 'display-startup-echo-area-message #'ignore) ; No more startup message
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1) ; Hide menu bar at top
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
#+END_SRC
* Languages

Use iPython if it is installed.

#+BEGIN_SRC emacs-lisp
(when (executable-find "ipython")
  (setq python-shell-interpreter "ipython"))
#+END_SRC

* Set up =use-package=
** Always install all the packages

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t
        use-package-verbose t)
#+END_SRC

** Use :diminish with use-package

To remove or abbreviate a mode indicator in the modeline

#+BEGIN_SRC emacs-lisp
  (require 'diminish)
#+END_SRC

** Use :bind-key with use-package

To bind keys easily in a tidy way

#+BEGIN_SRC emacs-lisp
  (require 'bind-key)
#+END_SRC

* Asynchronous compilation

#+BEGIN_SRC emacs-lisp
  (use-package async
    :init (setq async-bytecomp-allowed-packages '(all))
    :config
#+END_SRC

Enable aysnc commands for directory editor, also for helm
#+BEGIN_SRC emacs-lisp
  (dired-async-mode 1)
#+END_SRC

See https://github.com/jwiegley/emacs-async for explanation
#+BEGIN_SRC emacs-lisp
  (async-bytecomp-package-mode 1))
#+END_SRC

* UI

#+BEGIN_SRC emacs-lisp
  ;(use-package zenburn-theme)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package powerline
    :config (powerline-default-theme))
#+END_SRC

** airline

#+BEGIN_SRC emacs-lisp
  (use-package airline-themes
    :after powerline
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :init (setq powerline-utf-8-separator-left        #xe0b0
              powerline-utf-8-separator-right       #xe0b2
              airline-utf-glyph-separator-left      #xe0b0
              airline-utf-glyph-separator-right     #xe0b2
              airline-utf-glyph-subseparator-left   #xe0b1
              airline-utf-glyph-subseparator-right  #xe0b3
              airline-utf-glyph-branch              #xe0a0
              airline-utf-glyph-readonly            #xe0a2
              airline-utf-glyph-linenumber          #xe0a1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :config (load-theme 'airline-light t))
#+END_SRC

** whitespace

#+BEGIN_SRC emacs-lisp
  (use-package whitespace ; Built-in
    :diminish (whitespace-mode global-whitespace-mode)
    :init (setq whitespace-style '(face tabs trailing empty tab-mark))
    :config (global-whitespace-mode))
#+END_SRC

* Keys

** guide-key

#+BEGIN_SRC emacs-lisp
  (use-package guide-key
    :diminish guide-key-mode
    :config
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq guide-key/guide-key-sequence t ; Enable guide-key for all key sequences
#+END_SRC

#+BEGIN_SRC emacs-lisp
  guide-key/popup-window-position 'bottom)
  (guide-key-mode)) ; Enable guide-key-mode
#+END_SRC

** general

#+BEGIN_SRC emacs-lisp
  (use-package general
    :init
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq general-default-keymaps '(evil-normal-state-map
                                  evil-visual-state-map
                                  evil-operator-state-map)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  general-default-prefix "<SPC>")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :config

  (general-define-key "rb" 'eval-buffer)
  (general-define-key "rr" 'eval-region)
  (general-define-key "rl" 'dot-emacs/load-configuration-dot-org)

  (general-define-key "w" 'save-buffer)
  (general-define-key "0" 'delete-other-windows)
  (general-define-key "qq" 'save-buffers-kill-terminal)

  (general-define-key "hk" 'describe-key)
  (general-define-key "hf" 'describe-function)
  (general-define-key "hv" 'describe-variable)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (general-define-key :prefix nil
                      :keymaps '(swift-mode-map
                                 python-mode-map
                                 emacs-lisp-mode-map
                                 org-mode-map
                                 enh-ruby-mode-map)
                      :states '(insert emacs)
                      ";" '(lambda () (interactive) (insert ":"))
                      ":" '(lambda () (interactive) (insert ";")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun dot-emacs/copy-to-clipboard ()
    (interactive)
    (if (region-active-p)
        (progn
          (shell-command-on-region (region-beginning) (region-end) "pbcopy")
          (message "Yanked region to clipboard!")
          (deactivate-mark))
      (message "No region active; can't yank to clipboard!")))

  (general-define-key "y" 'dot-emacs/copy-to-clipboard)

#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun dot-emacs/paste-from-clipboard ()
    (interactive)
    (insert (shell-command-to-string "pbpaste")))

  (general-define-key "p" 'dot-emacs/paste-from-clipboard)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun dot-emacs/edit (filename)
    (find-file (concat user-emacs-directory filename)))

  (defun dot-emacs/edit-configuration ()
    (interactive)
    (dot-emacs/edit "configuration.org"))

  (general-define-key "ee" 'dot-emacs/edit-configuration))
#+END_SRC

* time
#+BEGIN_SRC emacs-lisp
  (use-package time ; Built-in
    :diminish display-time-mode
    :init
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (general-define-key "it" 'display-time-world)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq display-time-world-list '(
                                  ("Australia/Sydney" "Sydney")
                                  ("Asia/Chongqing" "Chongqing")
                                  ("PST8PDT" "San Francisco")
                                  ("Asia/Calcutta" "Bangalore")
                                  ("Australia/Melbourne" "Melbourne")
                                  ("Europe/London" "London")
                                  ("Europe/Paris" "Paris")
                                  ("Asia/Tokyo" "Tokyo")
                                  ("America/Los_Angeles" "Los Angeles")
                                  ("America/New_York" "New York")
                                  ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :config (display-time-mode))
#+END_SRC

* Org

** Load lazily based on the =:commands=

#+BEGIN_SRC emacs-lisp
  (use-package org
    :commands (org-agenda
               org-capture
               org-store-link
               org-iswitchb)
    :init
#+END_SRC

** Settings

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "â¤µ")
  (setq org-src-tab-acts-natively t)
  (setq org-log-done 'time)
  (setq org-todo-keywords
        '((sequence "TODO" "STARTED" "|" "DONE" "BLOCKED")))
#+END_SRC

** Capture templates

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "Todo"
           entry
           (file+headline org-default-notes-file "Personal")
           "* TODO %?\nCREATED: %u\n%i")

          ("p" "Todo w/ a file path"
           entry
           (file+headline org-default-notes-file "Personal")
           "* TODO %?\nCREATED: %u\n%i\n%l")

          ("w" "TODO :work:"
           entry
           (file+headline org-default-notes-file "Work")
           "* TODO %?\nCREATED: %u\n%i\n%l")

          ("s" "Investing in myself"
           entry
           (file+headline org-default-notes-file "Self-investment")
           "* TODO %?\nCREATED: %u\n%i")

          ("e" "Emacs: Investing in myself"
           entry
           (file+headline org-default-notes-file "Self-investment" "emacs")
           "* TODO %?\nCREATED: %u\n%i")

          ("b" "Blog idea"
           entry
           (file (org-file-path "blog-ideas.org"))
           "* %?\n")

          ;("e" "Email" entry
          ; (file+headline org-index-file "Inbox")
          ; "* TODO %?\nCREATED: %u\n%a\n")


          ;("s" "Subscribe to an RSS feed"
          ; plain
          ; (file "~/documents/rss/urls")
          ; "%^{Feed URL} \"~%^{Feed name}\"")

          ("f" "Finished book"
           table-line (org-file-path "books-read.org")
           "| %^{Title} | %^{Author} | %u |")

          ("r" "Reading"
           checkitem
           (file (org-file-path "to-read.org")))))
#+END_SRC

** Set up locations

#+BEGIN_SRC emacs-lisp
    (setq org-directory "~/Dropbox/data/org/")
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun org-file-path (filename)
      "Return the absolute address of an org file, given its relative name."
      (let ((file-path (concat (file-name-as-directory org-directory) filename)))
        (if (file-exists-p file-path)
            file-path nil)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (setq org-default-notes-file (org-file-path "notes.org"))
    (setq org-agenda-files (cl-remove-if #'null (list org-directory
                                                      (org-file-path "work/"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (setq org-archive-location
          (concat (org-file-path "archive.org") "::* From %s"))
#+END_SRC

** Magic: "It is done after its all subentries are done"

Switch entry to DONE when all subentries are done, to TODO otherwise.

#+BEGIN_SRC emacs-lisp
    (defun org-summary-todo (n-done n-not-done)
      "Switch entry to DONE when all subentries are done, to TODO otherwise."
      (let (org-log-done org-log-states)   ; turn off logging
        (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

    (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+END_SRC

** Keybindings

#+BEGIN_SRC emacs-lisp
  (general-define-key "oa" 'org-agenda)
  (general-define-key "oc" 'org-capture)
  (general-define-key "ol" 'org-store-link)
  (general-define-key "ob" 'org-iswitchb)

  (general-define-key "oo" '(lambda ()
                              (interactive)
                              (org-capture nil "t"))
                      "on" '(lambda ()
                              (interactive)
                              (find-file org-default-notes-file)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (general-define-key "tg" 'org-timer-start
                      "ts" 'org-timer-stop
                      "tp" 'org-timer-pause-or-continue)
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun evil-org-eol-call (fun &rest arguments)
      "Go to end of line and call provided function.
  FUN function callback
  Optional argument ARGUMENTS arguments to pass to FUN."
      (end-of-visible-line)
      (apply fun arguments)
      (evil-insert nil))

    (general-define-key :prefix nil
                        :keymaps 'org-mode-map
                        :states '(normal)
                        "tt" 'org-set-tags
                        "ti" (lambda ()
                               (interactive)
                               (evil-org-eol-call
                                #'org-insert-todo-heading-respect-content)))
#+END_SRC

** Add structure templates

#+BEGIN_SRC emacs-lisp
    :config
    (dolist (item '(("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
                    ("re" "#+END_SRC\n?\n#+BEGIN_SRC emacs-lisp")))
      (add-to-list 'org-structure-template-alist item))
#+END_SRC

** Add hooks

#+BEGIN_SRC emacs-lisp
    (add-hook 'org-mode-hook (lambda () (org-indent-mode t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun dot-emacs/org-clock-in-if-starting ()
    "Clock in when the task is marked STARTED."
    (when (and (string= org-state "STARTED")
               (not (string= org-last-state org-state)))
      (org-clock-in)))

  (add-hook 'org-after-todo-state-change-hook
            'dot-emacs/org-clock-in-if-starting)

  (defadvice org-clock-in (after dot-emacs activate)
    "Set this task's status to 'STARTED'."
    (org-todo "STARTED"))

  (defun dot-emacs/org-clock-out-if-waiting ()
    "Clock out when the task is marked WAITING."
    (when (and (or (string= org-state "DONE")
                   (string= org-state "BLOCKED"))
               (equal (marker-buffer org-clock-marker) (current-buffer))
               (< (point) org-clock-marker)
               (> (save-excursion (outline-next-heading) (point))
                  org-clock-marker)
               (not (string= org-last-state org-state)))
      (org-clock-out)))

  (add-hook 'org-after-todo-state-change-hook
            'dot-emacs/org-clock-out-if-waiting)
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (eval-after-load 'org-indent '(diminish 'org-indent-mode)))
#+END_SRC

* Evil

** evil
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :diminish undo-tree-mode
    :init
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq evil-want-C-u-scroll t ; Enable <c-u> to scroll up
#+END_SRC

#+BEGIN_SRC emacs-lisp
  evil-want-C-i-jump nil ; Disable C-i & TAB for jumps forward (conflicting with evil-org's TAB)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  evil-regexp-search t ; Enable regexp search
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :config
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map ";" #'evil-ex)
  (define-key evil-normal-state-map ":" #'evil-repeat-find-char)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (evil-mode))
#+END_SRC

** evil-escape
#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
    :diminish evil-escape-mode
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :init (setq-default evil-escape-key-sequence "kj")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :config
  (evil-escape-mode))
#+END_SRC

** evil-magit

#+BEGIN_SRC emacs-lisp
  (use-package evil-magit
    :after evil
    :config (evil-magit-init))

  (use-package evil-easymotion
    :after evil
    :config
#+END_SRC

#+BEGIN_SRC emacs-lisp
                                          ; Evil-easymotion's line movements work perfectly with evil.
  (general-define-key "j" (evilem-create 'evil-next-line))
  (general-define-key "k" (evilem-create 'evil-previous-line)))

  (general-define-key :prefix nil
                      :states '(motion operator)
                      "t" (evilem-create 'evil-repeat-find-char-to))
                                         ;:scope 'line))
#+END_SRC

** evil-surround

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :after evil
    :config (global-evil-surround-mode))
#+END_SRC
* avy

Avy's line movements do not work with evil too well.
For example, when in visual line selection mode (V), avy does not work at all;
and when it does work in visual selection mode (v), it selects the line before selection.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :commands (avy-goto-char-2 avy-goto-line-above avy-goto-line-below)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :bind (
         :map evil-normal-state-map
              ("f" . avy-goto-char-2)
              :map evil-visual-state-map
              ("f" . avy-goto-char-in-line)
              :map evil-operator-state-map
              ("f" . avy-goto-char-in-line))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :init
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq avy-keys '(?a ?e ?i ?o ?u ?h ?t ?d ?s)))
#+END_SRC

* Packages for Languages

** yasnippet

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (yas-reload-all)
    (add-hook 'prog-mode-hook #'yas-minor-mode))
#+END_SRC

** Swift
#+BEGIN_SRC emacs-lisp
  (use-package swift-mode
    :mode "\\.swift\\'"
    :interpreter "swift")
#+END_SRC

** Ruby

#+BEGIN_SRC emacs-lisp
  (use-package enh-ruby-mode
    :mode ("\\.rb\\'" "\\Brewfile\\'"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package inf-ruby)
#+END_SRC

*** Testing

#+BEGIN_SRC emacs-lisp
  (use-package rspec-mode
    :config
    (add-hook 'ruby-mode-hook 'rspec-mode)
    (rspec-install-snippets))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package minitest
    :config
    (add-hook 'ruby-mode-hook 'minitest-mode)
    (minitest-install-snippets))
#+END_SRC

*** Rake & Bundler

#+BEGIN_SRC emacs-lisp
  (use-package rake
    :init (setq rake-completion-system 'helm))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package bundler)
#+END_SRC

** Fish

#+BEGIN_SRC emacs-lisp
  (use-package fish-mode
    :mode "\\.fish\\'")
#+END_SRC

* Functionality

** perspective

#+BEGIN_SRC emacs-lisp
  (use-package perspective)
#+END_SRC

*** TODO Add helm projectile perspective integration

** autorevert

#+BEGIN_SRC emacs-lisp
  (use-package autorevert ; Built-in
    :config
    (global-auto-revert-mode))
#+END_SRC

** evil-org
#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :after (org evil)
    :diminish (evil-org-mode)
    :mode ("\\.org\\'" . org-mode)
    :config
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'evil-org-mode)
  (add-hook 'evil-org-mode-hook
            (lambda ()
              (evil-org-set-key-theme '(navigation insert textobjects additional)))))
#+END_SRC

** flx

#+BEGIN_SRC emacs-lisp
  (use-package flx)
#+END_SRC

** company

#+BEGIN_SRC emacs-lisp
  (use-package company
    :init (setq company-backends '(company-clang company-capf company-files company-yasnippet
                                                 (company-dabbrev-code company-gtags company-keywords))
                )
    :config
    (add-hook 'after-init-hook 'global-company-mode))

  (use-package company-flx
    :after (company flx)
    :config (company-flx-mode))
#+END_SRC

** auto-complete

#+BEGIN_SRC emacs-lisp
  ;(use-package auto-complete
  ;  :diminish auto-complete-mode
  ;  ;:init (setq ac-use-fuzzy t)
  ;  :config
  ;  (ac-config-default))
#+END_SRC

** projectile

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :init
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq projectile-enable-caching t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq projectile-switch-project-action 'helm-ls-git-ls)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq projectile-mode-line '(:eval (format " [%s]" (projectile-project-name))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :config
  (defalias 'run-command 'projectile-run-shell-command-in-root)
  (projectile-discover-projects-in-directory "~/work")
  (projectile-discover-projects-in-directory "~/proj")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode))
#+END_SRC

** projectile-ripgrep

#+BEGIN_SRC emacs-lisp
  (use-package projectile-ripgrep
    :after (projectile)
    :commands (projectile-ripgrep))
#+END_SRC

** Other

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :diminish auto-revert-mode
    :commands magit-status
    :init
    ;(defun t ()
    ;  (message (buffer-string)))

    ;(add-hook 'git-commit-mode-hook 't)
    (general-define-key "s" 'magit-status))

  (use-package ggtags
    :commands (ggtags-update-tags))

  (use-package smartparens
    :diminish smartparens-mode
    :config
    (require 'smartparens-config)
    (smartparens-global-mode)
    (show-smartparens-global-mode))

  (use-package slack
    :commands (slack-start)
    :init
    (setq slack-buffer-emojify t) ;; if you want to enable emoji, default nil
    (setq slack-prefer-current-team t))

  (use-package alert
    :commands (alert)
    :init
    (setq alert-default-style 'notifier))
#+END_SRC

* Helm

** helm

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :demand t
    :diminish helm-mode
    :bind ("M-x" . helm-M-x)
    :init
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq helm-mode-fuzzy-match t
        helm-completion-in-region-fuzzy-match t
        helm-M-x-fuzzy-match t
        helm-buffers-fuzzy-matching t
        helm-candidate-number-limit 20)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq helm-grep-ag-command "rg --color=always --colors 'match:fg:black' --colors 'match:bg:yellow' --smart-case --no-heading --line-number %s %s %s")
  (setq helm-grep-ag-pipe-cmd-switches '("--colors 'match:fg:black'" "--colors 'match:bg:yellow'"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (general-define-key "<SPC>" 'helm-M-x)
  (general-define-key "b" 'helm-buffers-list)

  (defun dot-emacs/grep-in-root ()
    (interactive)
    (projectile-with-default-dir (projectile-project-root)
      (call-interactively 'helm-do-grep-ag)))

  (general-define-key "g" 'dot-emacs/grep-in-root)
  :config
  (helm-mode))
#+END_SRC

** helm-flx

#+BEGIN_SRC emacs-lisp
  (use-package helm-flx
    :after (helm flx)
    :init
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq helm-flx-for-helm-find-files t
        helm-flx-for-helm-locate t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :config (helm-flx-mode))
#+END_SRC

** helm-projectile

#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :after (helm helm-flx)
    :commands (helm-projectile-switch-project)
    :config
    (general-define-key "c" 'helm-projectile-switch-project))
#+END_SRC

** helm-ls-git

#+BEGIN_SRC emacs-lisp
  (use-package helm-ls-git
    :commands helm-ls-git-ls
    :init
                                          ;(setq helm-ls-git-fuzzy-match t)
    (general-define-key "f" 'helm-ls-git-ls))

#+END_SRC

** helm-gtags

#+BEGIN_SRC emacs-lisp
  (use-package helm-gtags
    :commands (helm-gtags-select
               helm-gtags-find-rtag
               helm-gtags-parse-file)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :init
  (setq helm-gtags-fuzzy-match t)

  (general-define-key :prefix nil
                      :keymaps '(swift-mode-map)
                      :states '(normal)
                      "t" 'helm-gtags-select)

  (general-define-key :keymaps '(swift-mode-map)
                      :states '(normal)
                      "t" 'helm-gtags-parse-file))
#+END_SRC

* rcodetools
#+BEGIN_SRC emacs-lisp
  (defvar xmpfilter-command-name "ruby -S xmpfilter --dev --fork --detect-rbtest"
    "The xmpfilter command name.")
  (defvar rct-option-history nil)                ;internal
  (defvar rct-option-local nil)     ;internal
  (make-variable-buffer-local 'rct-option-local)
  (defvar rct-debug nil
    "If non-nil, output debug message into *Messages*.")
  ;; (setq rct-debug t)

  (defadvice comment-dwim (around rct-hack activate)
    "If comment-dwim is successively called, add => mark."
    (if (and (eq major-mode 'ruby-mode)
             (eq last-command 'comment-dwim)
             ;; TODO =>check
             )
        (insert "=>")
      ad-do-it))
  ;; To remove this advice.
  ;; (progn (ad-disable-advice 'comment-dwim 'around 'rct-hack) (ad-update 'comment-dwim)) 

  (defun rct-current-line ()
    "Return the vertical position of point..."
    (+ (count-lines (point-min) (point))
       (if (= (current-column) 0) 1 0)))

  (defun rct-save-position (proc)
    "Evaluate proc with saving current-line/current-column/window-start."
    (let ((line (rct-current-line))
          (col  (current-column))
          (wstart (window-start)))
      (funcall proc)
      (goto-char (point-min))
      (forward-line (1- line))
      (move-to-column col)
      (set-window-start (selected-window) wstart)))

  (defun rct-interactive ()
    "All the rcodetools-related commands with prefix args read rcodetools' common option. And store option into buffer-local variable."
    (list
     (let ((option (or rct-option-local "")))
       (if current-prefix-arg
           (setq rct-option-local
                 (read-from-minibuffer "rcodetools option: " option nil nil 'rct-option-history))
         option))))  

  (defun rct-shell-command (command &optional buffer)
    "Replacement for `(shell-command-on-region (point-min) (point-max) command buffer t' because of encoding problem."
    (let ((input-rb (concat (make-temp-name "xmptmp-in") ".rb"))
          (output-rb (concat (make-temp-name "xmptmp-out") ".rb"))
          (coding-system-for-read buffer-file-coding-system))
      (write-region (point-min) (point-max) input-rb nil 'nodisp)
      (shell-command
       (rct-debuglog (format "%s %s > %s" command input-rb output-rb))
       t " *rct-error*")
      (with-current-buffer (or buffer (current-buffer))
        (insert-file-contents output-rb nil nil nil t))
      (delete-file input-rb)
      (delete-file output-rb)))

  (defvar xmpfilter-command-function 'xmpfilter-command)
  (defun xmp (&optional option)
    "Run xmpfilter for annotation/test/spec on whole buffer.
  See also `rct-interactive'. "
    (interactive (rct-interactive))
    (rct-save-position
     (lambda ()
       (rct-shell-command (funcall xmpfilter-command-function option)))))

  (defun xmpfilter-command (&optional option)
    "The xmpfilter command line, DWIM."
    (setq option (or option ""))
    (flet ((in-block (beg-re)
                     (save-excursion
                       (goto-char (point-min))
                       (when (re-search-forward beg-re nil t)
                         (let ((s (point)) e)
                           (when (re-search-forward "^end\n" nil t)
                             (setq e (point))
                             (goto-char s)
                             (re-search-forward "# => *$" e t)))))))
      (cond ((in-block "^class.+< Test::Unit::TestCase$")
             (format "%s --unittest %s" xmpfilter-command-name option))
            ((in-block "^\\(describe\\|context\\).+do$")
             (format "%s --spec %s" xmpfilter-command-name option))
            (t
             (format "%s %s" xmpfilter-command-name option)))))
  (require 'cl)

  (defun rct-debuglog (logmsg)
    "if `rct-debug' is non-nil, output LOGMSG into *Messages*. Returns LOGMSG."
    (if rct-debug
        (message "%s" logmsg))
  logmsg)

  (provide 'rcodetools)
#+END_SRC
